---
title: X.509 Operations
description: Working with X.509 certificates, extensions, and validation in ts-security
---

# X.509 Operations

This guide covers working with X.509 certificates in depth, including parsing, validation, extensions, and advanced operations.

## Overview

X.509 is the standard format for public key certificates. It defines:

- Certificate structure
- Extension formats
- Validation rules
- Revocation mechanisms

## Parsing Certificates

### Parse from PEM

```typescript
import { pki } from 'ts-security'

const certPem = `-----BEGIN CERTIFICATE-----
MIIDXTCCAkWgAwIBAgIJAJC1...
-----END CERTIFICATE-----`

const cert = pki.certificateFromPem(certPem)

console.log('Subject:', cert.subject)
console.log('Issuer:', cert.issuer)
console.log('Serial Number:', cert.serialNumber)
console.log('Valid From:', cert.validity.notBefore)
console.log('Valid To:', cert.validity.notAfter)
```

### Parse from DER

```typescript
import { pki, asn1 } from 'ts-security'

// From DER bytes
const derBytes = new Uint8Array([...])
const asn1Cert = asn1.fromDer(derBytes)
const cert = pki.certificateFromAsn1(asn1Cert)
```

### Parse Certificate Chain

```typescript
import { pki, pem } from 'ts-security'

function parseCertificateChain(chainPem: string) {
  const messages = pem.decode(chainPem)

  return messages
    .filter(msg => msg.type === 'CERTIFICATE')
    .map(msg => {
      const asn1Cert = asn1.fromDer(msg.body)
      return pki.certificateFromAsn1(asn1Cert)
    })
}

// Usage
const chain = parseCertificateChain(certChainPem)
console.log(`Chain contains ${chain.length} certificates`)

// First certificate is usually the end-entity (server) cert
// Last certificate is usually the root CA
```

## Certificate Extensions

### Reading Extensions

```typescript
import { pki } from 'ts-security'

function getExtensions(cert: any) {
  const extensions: Record<string, any> = {}

  // Basic Constraints
  const basicConstraints = cert.getExtension('basicConstraints')
  if (basicConstraints) {
    extensions.basicConstraints = {
      cA: basicConstraints.cA,
      pathLenConstraint: basicConstraints.pathLenConstraint,
    }
  }

  // Key Usage
  const keyUsage = cert.getExtension('keyUsage')
  if (keyUsage) {
    extensions.keyUsage = {
      digitalSignature: keyUsage.digitalSignature,
      nonRepudiation: keyUsage.nonRepudiation,
      keyEncipherment: keyUsage.keyEncipherment,
      dataEncipherment: keyUsage.dataEncipherment,
      keyAgreement: keyUsage.keyAgreement,
      keyCertSign: keyUsage.keyCertSign,
      cRLSign: keyUsage.cRLSign,
      encipherOnly: keyUsage.encipherOnly,
      decipherOnly: keyUsage.decipherOnly,
    }
  }

  // Extended Key Usage
  const extKeyUsage = cert.getExtension('extKeyUsage')
  if (extKeyUsage) {
    extensions.extKeyUsage = {
      serverAuth: extKeyUsage.serverAuth,
      clientAuth: extKeyUsage.clientAuth,
      codeSigning: extKeyUsage.codeSigning,
      emailProtection: extKeyUsage.emailProtection,
      timeStamping: extKeyUsage.timeStamping,
    }
  }

  // Subject Alternative Name
  const san = cert.getExtension('subjectAltName')
  if (san && san.altNames) {
    extensions.subjectAltName = san.altNames.map((alt: any) => {
      switch (alt.type) {
        case 1: return { type: 'email', value: alt.value }
        case 2: return { type: 'dns', value: alt.value }
        case 6: return { type: 'uri', value: alt.value }
        case 7: return { type: 'ip', value: alt.ip }
        default: return { type: 'other', value: alt.value }
      }
    })
  }

  // Subject Key Identifier
  const ski = cert.getExtension('subjectKeyIdentifier')
  if (ski) {
    extensions.subjectKeyIdentifier = ski.subjectKeyIdentifier
  }

  // Authority Key Identifier
  const aki = cert.getExtension('authorityKeyIdentifier')
  if (aki) {
    extensions.authorityKeyIdentifier = {
      keyIdentifier: aki.keyIdentifier,
      serialNumber: aki.serialNumber,
    }
  }

  // CRL Distribution Points
  const crlDist = cert.getExtension('cRLDistributionPoints')
  if (crlDist && crlDist.distributionPoints) {
    extensions.crlDistributionPoints = crlDist.distributionPoints.map(
      (dp: any) => dp.fullName?.map((name: any) => name.value)
    ).flat()
  }

  // Authority Information Access
  const aia = cert.getExtension('authorityInfoAccess')
  if (aia && aia.accessDescriptions) {
    extensions.authorityInfoAccess = aia.accessDescriptions.map(
      (desc: any) => ({
        method: desc.accessMethod,
        location: desc.accessLocation?.value,
      })
    )
  }

  return extensions
}
```

### Setting Extensions

```typescript
import { pki } from 'ts-security'

function setExtensions(cert: any, options: {
  isCA?: boolean
  pathLength?: number
  domains?: string[]
  ips?: string[]
  emails?: string[]
  ocspUrl?: string
  crlUrl?: string
}) {
  const extensions = []

  // Basic Constraints
  extensions.push({
    name: 'basicConstraints',
    cA: options.isCA ?? false,
    ...(options.pathLength !== undefined && {
      pathLenConstraint: options.pathLength,
    }),
    critical: true,
  })

  // Key Usage
  if (options.isCA) {
    extensions.push({
      name: 'keyUsage',
      keyCertSign: true,
      cRLSign: true,
      critical: true,
    })
  } else {
    extensions.push({
      name: 'keyUsage',
      digitalSignature: true,
      keyEncipherment: true,
      critical: true,
    })
  }

  // Extended Key Usage (for non-CA)
  if (!options.isCA) {
    extensions.push({
      name: 'extKeyUsage',
      serverAuth: true,
      clientAuth: true,
    })
  }

  // Subject Alternative Name
  const altNames = []

  if (options.domains) {
    for (const domain of options.domains) {
      altNames.push({ type: 2, value: domain }) // DNS
    }
  }

  if (options.ips) {
    for (const ip of options.ips) {
      altNames.push({ type: 7, ip }) // IP
    }
  }

  if (options.emails) {
    for (const email of options.emails) {
      altNames.push({ type: 1, value: email }) // Email
    }
  }

  if (altNames.length > 0) {
    extensions.push({
      name: 'subjectAltName',
      altNames,
    })
  }

  // Subject Key Identifier
  extensions.push({
    name: 'subjectKeyIdentifier',
  })

  // Authority Information Access
  if (options.ocspUrl) {
    extensions.push({
      name: 'authorityInfoAccess',
      accessDescriptions: [
        {
          accessMethod: pki.oids.ocsp,
          accessLocation: {
            type: 6, // URI
            value: options.ocspUrl,
          },
        },
      ],
    })
  }

  // CRL Distribution Points
  if (options.crlUrl) {
    extensions.push({
      name: 'cRLDistributionPoints',
      distributionPoints: [
        {
          fullName: [
            {
              type: 6, // URI
              value: options.crlUrl,
            },
          ],
        },
      ],
    })
  }

  cert.setExtensions(extensions)
}
```

## Certificate Validation

### Complete Validation

```typescript
import { pki } from 'ts-security'

interface ValidationResult {
  valid: boolean
  errors: string[]
  warnings: string[]
}

function validateCertificate(
  certPem: string,
  options: {
    caCerts?: string[]
    hostname?: string
    date?: Date
    checkRevocation?: boolean
  } = {}
): ValidationResult {
  const result: ValidationResult = {
    valid: true,
    errors: [],
    warnings: [],
  }

  try {
    const cert = pki.certificateFromPem(certPem)
    const now = options.date || new Date()

    // Check validity period
    if (now < cert.validity.notBefore) {
      result.errors.push('Certificate not yet valid')
      result.valid = false
    }

    if (now > cert.validity.notAfter) {
      result.errors.push('Certificate has expired')
      result.valid = false
    }

    // Check expiry warning (30 days)
    const daysToExpiry = Math.floor(
      (cert.validity.notAfter.getTime() - now.getTime()) /
      (1000 * 60 * 60 * 24)
    )
    if (daysToExpiry > 0 && daysToExpiry < 30) {
      result.warnings.push(`Certificate expires in ${daysToExpiry} days`)
    }

    // Validate chain if CA certs provided
    if (options.caCerts && options.caCerts.length > 0) {
      const caCertObjs = options.caCerts.map(ca =>
        pki.certificateFromPem(ca)
      )
      const caStore = pki.createCaStore(caCertObjs)

      try {
        pki.verifyCertificateChain(caStore, [cert])
      } catch (error) {
        result.errors.push(`Chain verification failed: ${error.message}`)
        result.valid = false
      }
    }

    // Validate hostname
    if (options.hostname) {
      if (!validateHostname(cert, options.hostname)) {
        result.errors.push(
          `Hostname '${options.hostname}' does not match certificate`
        )
        result.valid = false
      }
    }

    // Check key strength
    const keyBits = cert.publicKey.n?.bitLength()
    if (keyBits && keyBits < 2048) {
      result.warnings.push(`Weak key: ${keyBits} bits (minimum 2048 recommended)`)
    }

  } catch (error) {
    result.errors.push(`Failed to parse certificate: ${error.message}`)
    result.valid = false
  }

  return result
}

function validateHostname(cert: any, hostname: string): boolean {
  // Check Common Name
  const cn = cert.subject.getField('CN')
  if (cn && matchHostname(cn.value, hostname)) {
    return true
  }

  // Check Subject Alternative Names
  const san = cert.getExtension('subjectAltName')
  if (san && san.altNames) {
    for (const alt of san.altNames) {
      if (alt.type === 2) { // DNS
        if (matchHostname(alt.value, hostname)) {
          return true
        }
      }
    }
  }

  return false
}

function matchHostname(pattern: string, hostname: string): boolean {
  // Exact match
  if (pattern === hostname) {
    return true
  }

  // Wildcard match
  if (pattern.startsWith('*.')) {
    const suffix = pattern.substring(2)
    const parts = hostname.split('.')
    if (parts.length >= 2) {
      const hostSuffix = parts.slice(1).join('.')
      return hostSuffix === suffix
    }
  }

  return false
}
```

### Chain Building

```typescript
import { pki } from 'ts-security'

function buildCertificateChain(
  endEntityCert: any,
  intermediateCerts: any[],
  rootCerts: any[]
): any[] {
  const chain = [endEntityCert]
  let current = endEntityCert

  // Find intermediate certificates
  while (true) {
    const issuerCert = findIssuer(current, [
      ...intermediateCerts,
      ...rootCerts,
    ])

    if (!issuerCert) {
      break
    }

    chain.push(issuerCert)

    // Check if we've reached a self-signed (root) certificate
    if (isSelfSigned(issuerCert)) {
      break
    }

    current = issuerCert
  }

  return chain
}

function findIssuer(cert: any, candidates: any[]): any | null {
  for (const candidate of candidates) {
    // Check if candidate's subject matches cert's issuer
    if (matchesSubject(candidate, cert.issuer)) {
      // Verify signature
      try {
        if (candidate.verify(cert)) {
          return candidate
        }
      } catch {
        continue
      }
    }
  }
  return null
}

function matchesSubject(cert: any, issuer: any): boolean {
  const certSubject = cert.subject.attributes
    .map((a: any) => `${a.name}=${a.value}`)
    .sort()
    .join(',')

  const issuerAttrs = issuer.attributes
    .map((a: any) => `${a.name}=${a.value}`)
    .sort()
    .join(',')

  return certSubject === issuerAttrs
}

function isSelfSigned(cert: any): boolean {
  return matchesSubject(cert, cert.issuer)
}
```

## Distinguished Names

### Parsing Distinguished Names

```typescript
import { pki } from 'ts-security'

interface DistinguishedName {
  commonName?: string
  organization?: string
  organizationalUnit?: string
  country?: string
  state?: string
  locality?: string
  email?: string
}

function parseDistinguishedName(dn: any): DistinguishedName {
  const result: DistinguishedName = {}

  for (const attr of dn.attributes) {
    switch (attr.shortName) {
      case 'CN':
        result.commonName = attr.value
        break
      case 'O':
        result.organization = attr.value
        break
      case 'OU':
        result.organizationalUnit = attr.value
        break
      case 'C':
        result.country = attr.value
        break
      case 'ST':
        result.state = attr.value
        break
      case 'L':
        result.locality = attr.value
        break
      case 'E':
      case 'emailAddress':
        result.email = attr.value
        break
    }
  }

  return result
}

// Usage
const cert = pki.certificateFromPem(certPem)
const subject = parseDistinguishedName(cert.subject)
const issuer = parseDistinguishedName(cert.issuer)
```

### Creating Distinguished Names

```typescript
import { pki } from 'ts-security'

function createDistinguishedName(dn: DistinguishedName) {
  const attrs = []

  if (dn.commonName) {
    attrs.push({ shortName: 'CN', value: dn.commonName })
  }
  if (dn.organization) {
    attrs.push({ shortName: 'O', value: dn.organization })
  }
  if (dn.organizationalUnit) {
    attrs.push({ shortName: 'OU', value: dn.organizationalUnit })
  }
  if (dn.country) {
    attrs.push({ shortName: 'C', value: dn.country })
  }
  if (dn.state) {
    attrs.push({ shortName: 'ST', value: dn.state })
  }
  if (dn.locality) {
    attrs.push({ shortName: 'L', value: dn.locality })
  }
  if (dn.email) {
    attrs.push({ shortName: 'E', value: dn.email })
  }

  return attrs
}
```

## Certificate Fingerprints

### Calculate Fingerprints

```typescript
import { pki, sha1, sha256 } from 'ts-security'

function getCertificateFingerprints(certPem: string) {
  const cert = pki.certificateFromPem(certPem)
  const der = asn1.toDer(pki.certificateToAsn1(cert))
  const bytes = der.getBytes()

  // SHA-256 fingerprint
  const sha256Md = sha256.create()
  sha256Md.update(bytes)
  const sha256Fp = sha256Md.digest().toHex()

  // SHA-1 fingerprint (for legacy compatibility)
  const sha1Md = sha1.create()
  sha1Md.update(bytes)
  const sha1Fp = sha1Md.digest().toHex()

  return {
    sha256: formatFingerprint(sha256Fp),
    sha1: formatFingerprint(sha1Fp),
  }
}

function formatFingerprint(hex: string): string {
  return hex.toUpperCase().match(/.{2}/g)?.join(':') || hex
}

// Usage
const fps = getCertificateFingerprints(certPem)
console.log('SHA-256:', fps.sha256) // 12:AB:CD:EF:...
console.log('SHA-1:', fps.sha1)     // 12:AB:CD:EF:...
```

## Serial Number Management

### Generate Unique Serial Numbers

```typescript
import { random } from 'ts-security'

function generateSerialNumber(): string {
  // Generate 16 random bytes for serial number
  const bytes = random.getBytesSync(16)

  // Convert to hex and ensure it's positive (first bit = 0)
  let hex = bytes.toString('hex')
  const firstByte = Number.parseInt(hex.substring(0, 2), 16)
  if (firstByte >= 0x80) {
    // Ensure positive by setting first bit to 0
    hex = (firstByte & 0x7f).toString(16).padStart(2, '0') + hex.substring(2)
  }

  return hex
}

// Usage
const cert = pki.createCertificate()
cert.serialNumber = generateSerialNumber()
```

## Next Steps

- Review [Certificate Management](/guide/certificates)
- Learn about [HTTPS Setup](/guide/https)
- Explore the [PKI API Reference](/api/pki)
